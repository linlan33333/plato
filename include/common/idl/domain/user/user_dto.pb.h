// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user_dto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_5fdto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_5fdto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_5fdto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_5fdto_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_5fdto_2eproto;
namespace user {
class DeviceDTO;
struct DeviceDTODefaultTypeInternal;
extern DeviceDTODefaultTypeInternal _DeviceDTO_default_instance_;
class InformationDTO;
struct InformationDTODefaultTypeInternal;
extern InformationDTODefaultTypeInternal _InformationDTO_default_instance_;
class ProfileDTO;
struct ProfileDTODefaultTypeInternal;
extern ProfileDTODefaultTypeInternal _ProfileDTO_default_instance_;
class SettingDTO;
struct SettingDTODefaultTypeInternal;
extern SettingDTODefaultTypeInternal _SettingDTO_default_instance_;
class UserDTO;
struct UserDTODefaultTypeInternal;
extern UserDTODefaultTypeInternal _UserDTO_default_instance_;
}  // namespace user
PROTOBUF_NAMESPACE_OPEN
template<> ::user::DeviceDTO* Arena::CreateMaybeMessage<::user::DeviceDTO>(Arena*);
template<> ::user::InformationDTO* Arena::CreateMaybeMessage<::user::InformationDTO>(Arena*);
template<> ::user::ProfileDTO* Arena::CreateMaybeMessage<::user::ProfileDTO>(Arena*);
template<> ::user::SettingDTO* Arena::CreateMaybeMessage<::user::SettingDTO>(Arena*);
template<> ::user::UserDTO* Arena::CreateMaybeMessage<::user::UserDTO>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace user {

// ===================================================================

class UserDTO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.UserDTO) */ {
 public:
  inline UserDTO() : UserDTO(nullptr) {}
  ~UserDTO() override;
  explicit constexpr UserDTO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserDTO(const UserDTO& from);
  UserDTO(UserDTO&& from) noexcept
    : UserDTO() {
    *this = ::std::move(from);
  }

  inline UserDTO& operator=(const UserDTO& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserDTO& operator=(UserDTO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserDTO& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserDTO* internal_default_instance() {
    return reinterpret_cast<const UserDTO*>(
               &_UserDTO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserDTO& a, UserDTO& b) {
    a.Swap(&b);
  }
  inline void Swap(UserDTO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserDTO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserDTO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserDTO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserDTO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserDTO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserDTO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.UserDTO";
  }
  protected:
  explicit UserDTO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kSettingFieldNumber = 3,
    kInformationFieldNumber = 4,
    kPprofileFieldNumber = 5,
    kUserIDFieldNumber = 1,
  };
  // .user.DeviceDTO device = 2;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::user::DeviceDTO& device() const;
  PROTOBUF_NODISCARD ::user::DeviceDTO* release_device();
  ::user::DeviceDTO* mutable_device();
  void set_allocated_device(::user::DeviceDTO* device);
  private:
  const ::user::DeviceDTO& _internal_device() const;
  ::user::DeviceDTO* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::user::DeviceDTO* device);
  ::user::DeviceDTO* unsafe_arena_release_device();

  // .user.SettingDTO setting = 3;
  bool has_setting() const;
  private:
  bool _internal_has_setting() const;
  public:
  void clear_setting();
  const ::user::SettingDTO& setting() const;
  PROTOBUF_NODISCARD ::user::SettingDTO* release_setting();
  ::user::SettingDTO* mutable_setting();
  void set_allocated_setting(::user::SettingDTO* setting);
  private:
  const ::user::SettingDTO& _internal_setting() const;
  ::user::SettingDTO* _internal_mutable_setting();
  public:
  void unsafe_arena_set_allocated_setting(
      ::user::SettingDTO* setting);
  ::user::SettingDTO* unsafe_arena_release_setting();

  // .user.InformationDTO information = 4;
  bool has_information() const;
  private:
  bool _internal_has_information() const;
  public:
  void clear_information();
  const ::user::InformationDTO& information() const;
  PROTOBUF_NODISCARD ::user::InformationDTO* release_information();
  ::user::InformationDTO* mutable_information();
  void set_allocated_information(::user::InformationDTO* information);
  private:
  const ::user::InformationDTO& _internal_information() const;
  ::user::InformationDTO* _internal_mutable_information();
  public:
  void unsafe_arena_set_allocated_information(
      ::user::InformationDTO* information);
  ::user::InformationDTO* unsafe_arena_release_information();

  // .user.ProfileDTO pprofile = 5;
  bool has_pprofile() const;
  private:
  bool _internal_has_pprofile() const;
  public:
  void clear_pprofile();
  const ::user::ProfileDTO& pprofile() const;
  PROTOBUF_NODISCARD ::user::ProfileDTO* release_pprofile();
  ::user::ProfileDTO* mutable_pprofile();
  void set_allocated_pprofile(::user::ProfileDTO* pprofile);
  private:
  const ::user::ProfileDTO& _internal_pprofile() const;
  ::user::ProfileDTO* _internal_mutable_pprofile();
  public:
  void unsafe_arena_set_allocated_pprofile(
      ::user::ProfileDTO* pprofile);
  ::user::ProfileDTO* unsafe_arena_release_pprofile();

  // uint64 userID = 1;
  void clear_userid();
  uint64_t userid() const;
  void set_userid(uint64_t value);
  private:
  uint64_t _internal_userid() const;
  void _internal_set_userid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:user.UserDTO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::user::DeviceDTO* device_;
  ::user::SettingDTO* setting_;
  ::user::InformationDTO* information_;
  ::user::ProfileDTO* pprofile_;
  uint64_t userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fdto_2eproto;
};
// -------------------------------------------------------------------

class DeviceDTO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.DeviceDTO) */ {
 public:
  inline DeviceDTO() : DeviceDTO(nullptr) {}
  ~DeviceDTO() override;
  explicit constexpr DeviceDTO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceDTO(const DeviceDTO& from);
  DeviceDTO(DeviceDTO&& from) noexcept
    : DeviceDTO() {
    *this = ::std::move(from);
  }

  inline DeviceDTO& operator=(const DeviceDTO& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceDTO& operator=(DeviceDTO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceDTO& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceDTO* internal_default_instance() {
    return reinterpret_cast<const DeviceDTO*>(
               &_DeviceDTO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceDTO& a, DeviceDTO& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceDTO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceDTO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceDTO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceDTO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceDTO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceDTO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceDTO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.DeviceDTO";
  }
  protected:
  explicit DeviceDTO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOsFieldNumber = 2,
    kAppVersionFieldNumber = 3,
    kTypeFieldNumber = 4,
    kModelFieldNumber = 5,
    kDeviceIDFieldNumber = 1,
  };
  // string os = 2;
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string appVersion = 3;
  void clear_appversion();
  const std::string& appversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appversion();
  PROTOBUF_NODISCARD std::string* release_appversion();
  void set_allocated_appversion(std::string* appversion);
  private:
  const std::string& _internal_appversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appversion(const std::string& value);
  std::string* _internal_mutable_appversion();
  public:

  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string model = 5;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // uint64 deviceID = 1;
  void clear_deviceid();
  uint64_t deviceid() const;
  void set_deviceid(uint64_t value);
  private:
  uint64_t _internal_deviceid() const;
  void _internal_set_deviceid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:user.DeviceDTO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  uint64_t deviceid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fdto_2eproto;
};
// -------------------------------------------------------------------

class SettingDTO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.SettingDTO) */ {
 public:
  inline SettingDTO() : SettingDTO(nullptr) {}
  ~SettingDTO() override;
  explicit constexpr SettingDTO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SettingDTO(const SettingDTO& from);
  SettingDTO(SettingDTO&& from) noexcept
    : SettingDTO() {
    *this = ::std::move(from);
  }

  inline SettingDTO& operator=(const SettingDTO& from) {
    CopyFrom(from);
    return *this;
  }
  inline SettingDTO& operator=(SettingDTO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SettingDTO& default_instance() {
    return *internal_default_instance();
  }
  static inline const SettingDTO* internal_default_instance() {
    return reinterpret_cast<const SettingDTO*>(
               &_SettingDTO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SettingDTO& a, SettingDTO& b) {
    a.Swap(&b);
  }
  inline void Swap(SettingDTO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SettingDTO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SettingDTO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SettingDTO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SettingDTO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SettingDTO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SettingDTO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.SettingDTO";
  }
  protected:
  explicit SettingDTO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFontSizeFieldNumber = 1,
    kLanguageFieldNumber = 4,
    kDarkModeFieldNumber = 2,
    kReceiveNotificationFieldNumber = 3,
    kNotificationsFieldNumber = 5,
  };
  // string fontSize = 1;
  void clear_fontsize();
  const std::string& fontsize() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fontsize(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fontsize();
  PROTOBUF_NODISCARD std::string* release_fontsize();
  void set_allocated_fontsize(std::string* fontsize);
  private:
  const std::string& _internal_fontsize() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fontsize(const std::string& value);
  std::string* _internal_mutable_fontsize();
  public:

  // string language = 4;
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // bool darkMode = 2;
  void clear_darkmode();
  bool darkmode() const;
  void set_darkmode(bool value);
  private:
  bool _internal_darkmode() const;
  void _internal_set_darkmode(bool value);
  public:

  // bool receiveNotification = 3;
  void clear_receivenotification();
  bool receivenotification() const;
  void set_receivenotification(bool value);
  private:
  bool _internal_receivenotification() const;
  void _internal_set_receivenotification(bool value);
  public:

  // bool notifications = 5;
  void clear_notifications();
  bool notifications() const;
  void set_notifications(bool value);
  private:
  bool _internal_notifications() const;
  void _internal_set_notifications(bool value);
  public:

  // @@protoc_insertion_point(class_scope:user.SettingDTO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fontsize_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  bool darkmode_;
  bool receivenotification_;
  bool notifications_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fdto_2eproto;
};
// -------------------------------------------------------------------

class InformationDTO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.InformationDTO) */ {
 public:
  inline InformationDTO() : InformationDTO(nullptr) {}
  ~InformationDTO() override;
  explicit constexpr InformationDTO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InformationDTO(const InformationDTO& from);
  InformationDTO(InformationDTO&& from) noexcept
    : InformationDTO() {
    *this = ::std::move(from);
  }

  inline InformationDTO& operator=(const InformationDTO& from) {
    CopyFrom(from);
    return *this;
  }
  inline InformationDTO& operator=(InformationDTO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InformationDTO& default_instance() {
    return *internal_default_instance();
  }
  static inline const InformationDTO* internal_default_instance() {
    return reinterpret_cast<const InformationDTO*>(
               &_InformationDTO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InformationDTO& a, InformationDTO& b) {
    a.Swap(&b);
  }
  inline void Swap(InformationDTO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InformationDTO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InformationDTO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InformationDTO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InformationDTO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InformationDTO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InformationDTO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.InformationDTO";
  }
  protected:
  explicit InformationDTO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kAvatarFieldNumber = 3,
    kSignatureFieldNumber = 4,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string avatar = 3;
  void clear_avatar();
  const std::string& avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar();
  PROTOBUF_NODISCARD std::string* release_avatar();
  void set_allocated_avatar(std::string* avatar);
  private:
  const std::string& _internal_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar(const std::string& value);
  std::string* _internal_mutable_avatar();
  public:

  // string signature = 4;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:user.InformationDTO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fdto_2eproto;
};
// -------------------------------------------------------------------

class ProfileDTO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.ProfileDTO) */ {
 public:
  inline ProfileDTO() : ProfileDTO(nullptr) {}
  ~ProfileDTO() override;
  explicit constexpr ProfileDTO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileDTO(const ProfileDTO& from);
  ProfileDTO(ProfileDTO&& from) noexcept
    : ProfileDTO() {
    *this = ::std::move(from);
  }

  inline ProfileDTO& operator=(const ProfileDTO& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileDTO& operator=(ProfileDTO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProfileDTO& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileDTO* internal_default_instance() {
    return reinterpret_cast<const ProfileDTO*>(
               &_ProfileDTO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ProfileDTO& a, ProfileDTO& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileDTO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileDTO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileDTO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileDTO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProfileDTO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProfileDTO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileDTO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.ProfileDTO";
  }
  protected:
  explicit ProfileDTO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kGenderFieldNumber = 3,
    kTagsFieldNumber = 4,
    kAgeFieldNumber = 2,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // string gender = 3;
  void clear_gender();
  const std::string& gender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gender();
  PROTOBUF_NODISCARD std::string* release_gender();
  void set_allocated_gender(std::string* gender);
  private:
  const std::string& _internal_gender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gender(const std::string& value);
  std::string* _internal_mutable_gender();
  public:

  // string tags = 4;
  void clear_tags();
  const std::string& tags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tags();
  PROTOBUF_NODISCARD std::string* release_tags();
  void set_allocated_tags(std::string* tags);
  private:
  const std::string& _internal_tags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tags(const std::string& value);
  std::string* _internal_mutable_tags();
  public:

  // int32 age = 2;
  void clear_age();
  int32_t age() const;
  void set_age(int32_t value);
  private:
  int32_t _internal_age() const;
  void _internal_set_age(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:user.ProfileDTO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tags_;
  int32_t age_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_5fdto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserDTO

// uint64 userID = 1;
inline void UserDTO::clear_userid() {
  userid_ = uint64_t{0u};
}
inline uint64_t UserDTO::_internal_userid() const {
  return userid_;
}
inline uint64_t UserDTO::userid() const {
  // @@protoc_insertion_point(field_get:user.UserDTO.userID)
  return _internal_userid();
}
inline void UserDTO::_internal_set_userid(uint64_t value) {
  
  userid_ = value;
}
inline void UserDTO::set_userid(uint64_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:user.UserDTO.userID)
}

// .user.DeviceDTO device = 2;
inline bool UserDTO::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool UserDTO::has_device() const {
  return _internal_has_device();
}
inline void UserDTO::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::user::DeviceDTO& UserDTO::_internal_device() const {
  const ::user::DeviceDTO* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::DeviceDTO&>(
      ::user::_DeviceDTO_default_instance_);
}
inline const ::user::DeviceDTO& UserDTO::device() const {
  // @@protoc_insertion_point(field_get:user.UserDTO.device)
  return _internal_device();
}
inline void UserDTO::unsafe_arena_set_allocated_device(
    ::user::DeviceDTO* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UserDTO.device)
}
inline ::user::DeviceDTO* UserDTO::release_device() {
  
  ::user::DeviceDTO* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::user::DeviceDTO* UserDTO::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:user.UserDTO.device)
  
  ::user::DeviceDTO* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::user::DeviceDTO* UserDTO::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::user::DeviceDTO>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::user::DeviceDTO* UserDTO::mutable_device() {
  ::user::DeviceDTO* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:user.UserDTO.device)
  return _msg;
}
inline void UserDTO::set_allocated_device(::user::DeviceDTO* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::user::DeviceDTO>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:user.UserDTO.device)
}

// .user.SettingDTO setting = 3;
inline bool UserDTO::_internal_has_setting() const {
  return this != internal_default_instance() && setting_ != nullptr;
}
inline bool UserDTO::has_setting() const {
  return _internal_has_setting();
}
inline void UserDTO::clear_setting() {
  if (GetArenaForAllocation() == nullptr && setting_ != nullptr) {
    delete setting_;
  }
  setting_ = nullptr;
}
inline const ::user::SettingDTO& UserDTO::_internal_setting() const {
  const ::user::SettingDTO* p = setting_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::SettingDTO&>(
      ::user::_SettingDTO_default_instance_);
}
inline const ::user::SettingDTO& UserDTO::setting() const {
  // @@protoc_insertion_point(field_get:user.UserDTO.setting)
  return _internal_setting();
}
inline void UserDTO::unsafe_arena_set_allocated_setting(
    ::user::SettingDTO* setting) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setting_);
  }
  setting_ = setting;
  if (setting) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UserDTO.setting)
}
inline ::user::SettingDTO* UserDTO::release_setting() {
  
  ::user::SettingDTO* temp = setting_;
  setting_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::user::SettingDTO* UserDTO::unsafe_arena_release_setting() {
  // @@protoc_insertion_point(field_release:user.UserDTO.setting)
  
  ::user::SettingDTO* temp = setting_;
  setting_ = nullptr;
  return temp;
}
inline ::user::SettingDTO* UserDTO::_internal_mutable_setting() {
  
  if (setting_ == nullptr) {
    auto* p = CreateMaybeMessage<::user::SettingDTO>(GetArenaForAllocation());
    setting_ = p;
  }
  return setting_;
}
inline ::user::SettingDTO* UserDTO::mutable_setting() {
  ::user::SettingDTO* _msg = _internal_mutable_setting();
  // @@protoc_insertion_point(field_mutable:user.UserDTO.setting)
  return _msg;
}
inline void UserDTO::set_allocated_setting(::user::SettingDTO* setting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete setting_;
  }
  if (setting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::user::SettingDTO>::GetOwningArena(setting);
    if (message_arena != submessage_arena) {
      setting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setting, submessage_arena);
    }
    
  } else {
    
  }
  setting_ = setting;
  // @@protoc_insertion_point(field_set_allocated:user.UserDTO.setting)
}

// .user.InformationDTO information = 4;
inline bool UserDTO::_internal_has_information() const {
  return this != internal_default_instance() && information_ != nullptr;
}
inline bool UserDTO::has_information() const {
  return _internal_has_information();
}
inline void UserDTO::clear_information() {
  if (GetArenaForAllocation() == nullptr && information_ != nullptr) {
    delete information_;
  }
  information_ = nullptr;
}
inline const ::user::InformationDTO& UserDTO::_internal_information() const {
  const ::user::InformationDTO* p = information_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::InformationDTO&>(
      ::user::_InformationDTO_default_instance_);
}
inline const ::user::InformationDTO& UserDTO::information() const {
  // @@protoc_insertion_point(field_get:user.UserDTO.information)
  return _internal_information();
}
inline void UserDTO::unsafe_arena_set_allocated_information(
    ::user::InformationDTO* information) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(information_);
  }
  information_ = information;
  if (information) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UserDTO.information)
}
inline ::user::InformationDTO* UserDTO::release_information() {
  
  ::user::InformationDTO* temp = information_;
  information_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::user::InformationDTO* UserDTO::unsafe_arena_release_information() {
  // @@protoc_insertion_point(field_release:user.UserDTO.information)
  
  ::user::InformationDTO* temp = information_;
  information_ = nullptr;
  return temp;
}
inline ::user::InformationDTO* UserDTO::_internal_mutable_information() {
  
  if (information_ == nullptr) {
    auto* p = CreateMaybeMessage<::user::InformationDTO>(GetArenaForAllocation());
    information_ = p;
  }
  return information_;
}
inline ::user::InformationDTO* UserDTO::mutable_information() {
  ::user::InformationDTO* _msg = _internal_mutable_information();
  // @@protoc_insertion_point(field_mutable:user.UserDTO.information)
  return _msg;
}
inline void UserDTO::set_allocated_information(::user::InformationDTO* information) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete information_;
  }
  if (information) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::user::InformationDTO>::GetOwningArena(information);
    if (message_arena != submessage_arena) {
      information = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, information, submessage_arena);
    }
    
  } else {
    
  }
  information_ = information;
  // @@protoc_insertion_point(field_set_allocated:user.UserDTO.information)
}

// .user.ProfileDTO pprofile = 5;
inline bool UserDTO::_internal_has_pprofile() const {
  return this != internal_default_instance() && pprofile_ != nullptr;
}
inline bool UserDTO::has_pprofile() const {
  return _internal_has_pprofile();
}
inline void UserDTO::clear_pprofile() {
  if (GetArenaForAllocation() == nullptr && pprofile_ != nullptr) {
    delete pprofile_;
  }
  pprofile_ = nullptr;
}
inline const ::user::ProfileDTO& UserDTO::_internal_pprofile() const {
  const ::user::ProfileDTO* p = pprofile_;
  return p != nullptr ? *p : reinterpret_cast<const ::user::ProfileDTO&>(
      ::user::_ProfileDTO_default_instance_);
}
inline const ::user::ProfileDTO& UserDTO::pprofile() const {
  // @@protoc_insertion_point(field_get:user.UserDTO.pprofile)
  return _internal_pprofile();
}
inline void UserDTO::unsafe_arena_set_allocated_pprofile(
    ::user::ProfileDTO* pprofile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pprofile_);
  }
  pprofile_ = pprofile;
  if (pprofile) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:user.UserDTO.pprofile)
}
inline ::user::ProfileDTO* UserDTO::release_pprofile() {
  
  ::user::ProfileDTO* temp = pprofile_;
  pprofile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::user::ProfileDTO* UserDTO::unsafe_arena_release_pprofile() {
  // @@protoc_insertion_point(field_release:user.UserDTO.pprofile)
  
  ::user::ProfileDTO* temp = pprofile_;
  pprofile_ = nullptr;
  return temp;
}
inline ::user::ProfileDTO* UserDTO::_internal_mutable_pprofile() {
  
  if (pprofile_ == nullptr) {
    auto* p = CreateMaybeMessage<::user::ProfileDTO>(GetArenaForAllocation());
    pprofile_ = p;
  }
  return pprofile_;
}
inline ::user::ProfileDTO* UserDTO::mutable_pprofile() {
  ::user::ProfileDTO* _msg = _internal_mutable_pprofile();
  // @@protoc_insertion_point(field_mutable:user.UserDTO.pprofile)
  return _msg;
}
inline void UserDTO::set_allocated_pprofile(::user::ProfileDTO* pprofile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pprofile_;
  }
  if (pprofile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::user::ProfileDTO>::GetOwningArena(pprofile);
    if (message_arena != submessage_arena) {
      pprofile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pprofile, submessage_arena);
    }
    
  } else {
    
  }
  pprofile_ = pprofile;
  // @@protoc_insertion_point(field_set_allocated:user.UserDTO.pprofile)
}

// -------------------------------------------------------------------

// DeviceDTO

// uint64 deviceID = 1;
inline void DeviceDTO::clear_deviceid() {
  deviceid_ = uint64_t{0u};
}
inline uint64_t DeviceDTO::_internal_deviceid() const {
  return deviceid_;
}
inline uint64_t DeviceDTO::deviceid() const {
  // @@protoc_insertion_point(field_get:user.DeviceDTO.deviceID)
  return _internal_deviceid();
}
inline void DeviceDTO::_internal_set_deviceid(uint64_t value) {
  
  deviceid_ = value;
}
inline void DeviceDTO::set_deviceid(uint64_t value) {
  _internal_set_deviceid(value);
  // @@protoc_insertion_point(field_set:user.DeviceDTO.deviceID)
}

// string os = 2;
inline void DeviceDTO::clear_os() {
  os_.ClearToEmpty();
}
inline const std::string& DeviceDTO::os() const {
  // @@protoc_insertion_point(field_get:user.DeviceDTO.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceDTO::set_os(ArgT0&& arg0, ArgT... args) {
 
 os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.DeviceDTO.os)
}
inline std::string* DeviceDTO::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:user.DeviceDTO.os)
  return _s;
}
inline const std::string& DeviceDTO::_internal_os() const {
  return os_.Get();
}
inline void DeviceDTO::_internal_set_os(const std::string& value) {
  
  os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceDTO::_internal_mutable_os() {
  
  return os_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceDTO::release_os() {
  // @@protoc_insertion_point(field_release:user.DeviceDTO.os)
  return os_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceDTO::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  os_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.DeviceDTO.os)
}

// string appVersion = 3;
inline void DeviceDTO::clear_appversion() {
  appversion_.ClearToEmpty();
}
inline const std::string& DeviceDTO::appversion() const {
  // @@protoc_insertion_point(field_get:user.DeviceDTO.appVersion)
  return _internal_appversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceDTO::set_appversion(ArgT0&& arg0, ArgT... args) {
 
 appversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.DeviceDTO.appVersion)
}
inline std::string* DeviceDTO::mutable_appversion() {
  std::string* _s = _internal_mutable_appversion();
  // @@protoc_insertion_point(field_mutable:user.DeviceDTO.appVersion)
  return _s;
}
inline const std::string& DeviceDTO::_internal_appversion() const {
  return appversion_.Get();
}
inline void DeviceDTO::_internal_set_appversion(const std::string& value) {
  
  appversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceDTO::_internal_mutable_appversion() {
  
  return appversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceDTO::release_appversion() {
  // @@protoc_insertion_point(field_release:user.DeviceDTO.appVersion)
  return appversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceDTO::set_allocated_appversion(std::string* appversion) {
  if (appversion != nullptr) {
    
  } else {
    
  }
  appversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appversion,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (appversion_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    appversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.DeviceDTO.appVersion)
}

// string type = 4;
inline void DeviceDTO::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& DeviceDTO::type() const {
  // @@protoc_insertion_point(field_get:user.DeviceDTO.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceDTO::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.DeviceDTO.type)
}
inline std::string* DeviceDTO::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:user.DeviceDTO.type)
  return _s;
}
inline const std::string& DeviceDTO::_internal_type() const {
  return type_.Get();
}
inline void DeviceDTO::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceDTO::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceDTO::release_type() {
  // @@protoc_insertion_point(field_release:user.DeviceDTO.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceDTO::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.DeviceDTO.type)
}

// string model = 5;
inline void DeviceDTO::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& DeviceDTO::model() const {
  // @@protoc_insertion_point(field_get:user.DeviceDTO.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceDTO::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.DeviceDTO.model)
}
inline std::string* DeviceDTO::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:user.DeviceDTO.model)
  return _s;
}
inline const std::string& DeviceDTO::_internal_model() const {
  return model_.Get();
}
inline void DeviceDTO::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceDTO::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceDTO::release_model() {
  // @@protoc_insertion_point(field_release:user.DeviceDTO.model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceDTO::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.DeviceDTO.model)
}

// -------------------------------------------------------------------

// SettingDTO

// string fontSize = 1;
inline void SettingDTO::clear_fontsize() {
  fontsize_.ClearToEmpty();
}
inline const std::string& SettingDTO::fontsize() const {
  // @@protoc_insertion_point(field_get:user.SettingDTO.fontSize)
  return _internal_fontsize();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SettingDTO::set_fontsize(ArgT0&& arg0, ArgT... args) {
 
 fontsize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.SettingDTO.fontSize)
}
inline std::string* SettingDTO::mutable_fontsize() {
  std::string* _s = _internal_mutable_fontsize();
  // @@protoc_insertion_point(field_mutable:user.SettingDTO.fontSize)
  return _s;
}
inline const std::string& SettingDTO::_internal_fontsize() const {
  return fontsize_.Get();
}
inline void SettingDTO::_internal_set_fontsize(const std::string& value) {
  
  fontsize_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SettingDTO::_internal_mutable_fontsize() {
  
  return fontsize_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SettingDTO::release_fontsize() {
  // @@protoc_insertion_point(field_release:user.SettingDTO.fontSize)
  return fontsize_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SettingDTO::set_allocated_fontsize(std::string* fontsize) {
  if (fontsize != nullptr) {
    
  } else {
    
  }
  fontsize_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fontsize,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fontsize_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fontsize_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.SettingDTO.fontSize)
}

// bool darkMode = 2;
inline void SettingDTO::clear_darkmode() {
  darkmode_ = false;
}
inline bool SettingDTO::_internal_darkmode() const {
  return darkmode_;
}
inline bool SettingDTO::darkmode() const {
  // @@protoc_insertion_point(field_get:user.SettingDTO.darkMode)
  return _internal_darkmode();
}
inline void SettingDTO::_internal_set_darkmode(bool value) {
  
  darkmode_ = value;
}
inline void SettingDTO::set_darkmode(bool value) {
  _internal_set_darkmode(value);
  // @@protoc_insertion_point(field_set:user.SettingDTO.darkMode)
}

// bool receiveNotification = 3;
inline void SettingDTO::clear_receivenotification() {
  receivenotification_ = false;
}
inline bool SettingDTO::_internal_receivenotification() const {
  return receivenotification_;
}
inline bool SettingDTO::receivenotification() const {
  // @@protoc_insertion_point(field_get:user.SettingDTO.receiveNotification)
  return _internal_receivenotification();
}
inline void SettingDTO::_internal_set_receivenotification(bool value) {
  
  receivenotification_ = value;
}
inline void SettingDTO::set_receivenotification(bool value) {
  _internal_set_receivenotification(value);
  // @@protoc_insertion_point(field_set:user.SettingDTO.receiveNotification)
}

// string language = 4;
inline void SettingDTO::clear_language() {
  language_.ClearToEmpty();
}
inline const std::string& SettingDTO::language() const {
  // @@protoc_insertion_point(field_get:user.SettingDTO.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SettingDTO::set_language(ArgT0&& arg0, ArgT... args) {
 
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.SettingDTO.language)
}
inline std::string* SettingDTO::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:user.SettingDTO.language)
  return _s;
}
inline const std::string& SettingDTO::_internal_language() const {
  return language_.Get();
}
inline void SettingDTO::_internal_set_language(const std::string& value) {
  
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SettingDTO::_internal_mutable_language() {
  
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SettingDTO::release_language() {
  // @@protoc_insertion_point(field_release:user.SettingDTO.language)
  return language_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SettingDTO::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.SettingDTO.language)
}

// bool notifications = 5;
inline void SettingDTO::clear_notifications() {
  notifications_ = false;
}
inline bool SettingDTO::_internal_notifications() const {
  return notifications_;
}
inline bool SettingDTO::notifications() const {
  // @@protoc_insertion_point(field_get:user.SettingDTO.notifications)
  return _internal_notifications();
}
inline void SettingDTO::_internal_set_notifications(bool value) {
  
  notifications_ = value;
}
inline void SettingDTO::set_notifications(bool value) {
  _internal_set_notifications(value);
  // @@protoc_insertion_point(field_set:user.SettingDTO.notifications)
}

// -------------------------------------------------------------------

// InformationDTO

// string nickname = 1;
inline void InformationDTO::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& InformationDTO::nickname() const {
  // @@protoc_insertion_point(field_get:user.InformationDTO.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InformationDTO::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.InformationDTO.nickname)
}
inline std::string* InformationDTO::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:user.InformationDTO.nickname)
  return _s;
}
inline const std::string& InformationDTO::_internal_nickname() const {
  return nickname_.Get();
}
inline void InformationDTO::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InformationDTO::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InformationDTO::release_nickname() {
  // @@protoc_insertion_point(field_release:user.InformationDTO.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InformationDTO::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.InformationDTO.nickname)
}

// string password = 2;
inline void InformationDTO::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& InformationDTO::password() const {
  // @@protoc_insertion_point(field_get:user.InformationDTO.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InformationDTO::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.InformationDTO.password)
}
inline std::string* InformationDTO::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:user.InformationDTO.password)
  return _s;
}
inline const std::string& InformationDTO::_internal_password() const {
  return password_.Get();
}
inline void InformationDTO::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InformationDTO::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InformationDTO::release_password() {
  // @@protoc_insertion_point(field_release:user.InformationDTO.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InformationDTO::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.InformationDTO.password)
}

// string avatar = 3;
inline void InformationDTO::clear_avatar() {
  avatar_.ClearToEmpty();
}
inline const std::string& InformationDTO::avatar() const {
  // @@protoc_insertion_point(field_get:user.InformationDTO.avatar)
  return _internal_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InformationDTO::set_avatar(ArgT0&& arg0, ArgT... args) {
 
 avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.InformationDTO.avatar)
}
inline std::string* InformationDTO::mutable_avatar() {
  std::string* _s = _internal_mutable_avatar();
  // @@protoc_insertion_point(field_mutable:user.InformationDTO.avatar)
  return _s;
}
inline const std::string& InformationDTO::_internal_avatar() const {
  return avatar_.Get();
}
inline void InformationDTO::_internal_set_avatar(const std::string& value) {
  
  avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InformationDTO::_internal_mutable_avatar() {
  
  return avatar_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InformationDTO::release_avatar() {
  // @@protoc_insertion_point(field_release:user.InformationDTO.avatar)
  return avatar_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InformationDTO::set_allocated_avatar(std::string* avatar) {
  if (avatar != nullptr) {
    
  } else {
    
  }
  avatar_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.InformationDTO.avatar)
}

// string signature = 4;
inline void InformationDTO::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& InformationDTO::signature() const {
  // @@protoc_insertion_point(field_get:user.InformationDTO.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InformationDTO::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.InformationDTO.signature)
}
inline std::string* InformationDTO::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:user.InformationDTO.signature)
  return _s;
}
inline const std::string& InformationDTO::_internal_signature() const {
  return signature_.Get();
}
inline void InformationDTO::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InformationDTO::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InformationDTO::release_signature() {
  // @@protoc_insertion_point(field_release:user.InformationDTO.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InformationDTO::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.InformationDTO.signature)
}

// -------------------------------------------------------------------

// ProfileDTO

// string location = 1;
inline void ProfileDTO::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& ProfileDTO::location() const {
  // @@protoc_insertion_point(field_get:user.ProfileDTO.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileDTO::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.ProfileDTO.location)
}
inline std::string* ProfileDTO::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:user.ProfileDTO.location)
  return _s;
}
inline const std::string& ProfileDTO::_internal_location() const {
  return location_.Get();
}
inline void ProfileDTO::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileDTO::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileDTO::release_location() {
  // @@protoc_insertion_point(field_release:user.ProfileDTO.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileDTO::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.ProfileDTO.location)
}

// int32 age = 2;
inline void ProfileDTO::clear_age() {
  age_ = 0;
}
inline int32_t ProfileDTO::_internal_age() const {
  return age_;
}
inline int32_t ProfileDTO::age() const {
  // @@protoc_insertion_point(field_get:user.ProfileDTO.age)
  return _internal_age();
}
inline void ProfileDTO::_internal_set_age(int32_t value) {
  
  age_ = value;
}
inline void ProfileDTO::set_age(int32_t value) {
  _internal_set_age(value);
  // @@protoc_insertion_point(field_set:user.ProfileDTO.age)
}

// string gender = 3;
inline void ProfileDTO::clear_gender() {
  gender_.ClearToEmpty();
}
inline const std::string& ProfileDTO::gender() const {
  // @@protoc_insertion_point(field_get:user.ProfileDTO.gender)
  return _internal_gender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileDTO::set_gender(ArgT0&& arg0, ArgT... args) {
 
 gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.ProfileDTO.gender)
}
inline std::string* ProfileDTO::mutable_gender() {
  std::string* _s = _internal_mutable_gender();
  // @@protoc_insertion_point(field_mutable:user.ProfileDTO.gender)
  return _s;
}
inline const std::string& ProfileDTO::_internal_gender() const {
  return gender_.Get();
}
inline void ProfileDTO::_internal_set_gender(const std::string& value) {
  
  gender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileDTO::_internal_mutable_gender() {
  
  return gender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileDTO::release_gender() {
  // @@protoc_insertion_point(field_release:user.ProfileDTO.gender)
  return gender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileDTO::set_allocated_gender(std::string* gender) {
  if (gender != nullptr) {
    
  } else {
    
  }
  gender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.ProfileDTO.gender)
}

// string tags = 4;
inline void ProfileDTO::clear_tags() {
  tags_.ClearToEmpty();
}
inline const std::string& ProfileDTO::tags() const {
  // @@protoc_insertion_point(field_get:user.ProfileDTO.tags)
  return _internal_tags();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileDTO::set_tags(ArgT0&& arg0, ArgT... args) {
 
 tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.ProfileDTO.tags)
}
inline std::string* ProfileDTO::mutable_tags() {
  std::string* _s = _internal_mutable_tags();
  // @@protoc_insertion_point(field_mutable:user.ProfileDTO.tags)
  return _s;
}
inline const std::string& ProfileDTO::_internal_tags() const {
  return tags_.Get();
}
inline void ProfileDTO::_internal_set_tags(const std::string& value) {
  
  tags_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileDTO::_internal_mutable_tags() {
  
  return tags_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileDTO::release_tags() {
  // @@protoc_insertion_point(field_release:user.ProfileDTO.tags)
  return tags_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileDTO::set_allocated_tags(std::string* tags) {
  if (tags != nullptr) {
    
  } else {
    
  }
  tags_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tags,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tags_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tags_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.ProfileDTO.tags)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace user

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_5fdto_2eproto
