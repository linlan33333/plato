// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace message {
class ACKMsg;
struct ACKMsgDefaultTypeInternal;
extern ACKMsgDefaultTypeInternal _ACKMsg_default_instance_;
class HeartbeatMsg;
struct HeartbeatMsgDefaultTypeInternal;
extern HeartbeatMsgDefaultTypeInternal _HeartbeatMsg_default_instance_;
class HeartbeatMsgHead;
struct HeartbeatMsgHeadDefaultTypeInternal;
extern HeartbeatMsgHeadDefaultTypeInternal _HeartbeatMsgHead_default_instance_;
class LoginMsg;
struct LoginMsgDefaultTypeInternal;
extern LoginMsgDefaultTypeInternal _LoginMsg_default_instance_;
class LoginMsgHead;
struct LoginMsgHeadDefaultTypeInternal;
extern LoginMsgHeadDefaultTypeInternal _LoginMsgHead_default_instance_;
class MsgCmd;
struct MsgCmdDefaultTypeInternal;
extern MsgCmdDefaultTypeInternal _MsgCmd_default_instance_;
class PushMsg;
struct PushMsgDefaultTypeInternal;
extern PushMsgDefaultTypeInternal _PushMsg_default_instance_;
class ReConnMsg;
struct ReConnMsgDefaultTypeInternal;
extern ReConnMsgDefaultTypeInternal _ReConnMsg_default_instance_;
class ReConnMsgHead;
struct ReConnMsgHeadDefaultTypeInternal;
extern ReConnMsgHeadDefaultTypeInternal _ReConnMsgHead_default_instance_;
class UPMsg;
struct UPMsgDefaultTypeInternal;
extern UPMsgDefaultTypeInternal _UPMsg_default_instance_;
class UPMsgHead;
struct UPMsgHeadDefaultTypeInternal;
extern UPMsgHeadDefaultTypeInternal _UPMsgHead_default_instance_;
}  // namespace message
PROTOBUF_NAMESPACE_OPEN
template<> ::message::ACKMsg* Arena::CreateMaybeMessage<::message::ACKMsg>(Arena*);
template<> ::message::HeartbeatMsg* Arena::CreateMaybeMessage<::message::HeartbeatMsg>(Arena*);
template<> ::message::HeartbeatMsgHead* Arena::CreateMaybeMessage<::message::HeartbeatMsgHead>(Arena*);
template<> ::message::LoginMsg* Arena::CreateMaybeMessage<::message::LoginMsg>(Arena*);
template<> ::message::LoginMsgHead* Arena::CreateMaybeMessage<::message::LoginMsgHead>(Arena*);
template<> ::message::MsgCmd* Arena::CreateMaybeMessage<::message::MsgCmd>(Arena*);
template<> ::message::PushMsg* Arena::CreateMaybeMessage<::message::PushMsg>(Arena*);
template<> ::message::ReConnMsg* Arena::CreateMaybeMessage<::message::ReConnMsg>(Arena*);
template<> ::message::ReConnMsgHead* Arena::CreateMaybeMessage<::message::ReConnMsgHead>(Arena*);
template<> ::message::UPMsg* Arena::CreateMaybeMessage<::message::UPMsg>(Arena*);
template<> ::message::UPMsgHead* Arena::CreateMaybeMessage<::message::UPMsgHead>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace message {

enum CmdType : int {
  Login = 0,
  Heartbeat = 1,
  ReConn = 2,
  ACK = 3,
  UP = 4,
  Push = 5,
  CmdType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CmdType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CmdType_IsValid(int value);
constexpr CmdType CmdType_MIN = Login;
constexpr CmdType CmdType_MAX = Push;
constexpr int CmdType_ARRAYSIZE = CmdType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CmdType_descriptor();
template<typename T>
inline const std::string& CmdType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CmdType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CmdType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CmdType_descriptor(), enum_t_value);
}
inline bool CmdType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CmdType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CmdType>(
    CmdType_descriptor(), name, value);
}
// ===================================================================

class MsgCmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.MsgCmd) */ {
 public:
  inline MsgCmd() : MsgCmd(nullptr) {}
  ~MsgCmd() override;
  explicit constexpr MsgCmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MsgCmd(const MsgCmd& from);
  MsgCmd(MsgCmd&& from) noexcept
    : MsgCmd() {
    *this = ::std::move(from);
  }

  inline MsgCmd& operator=(const MsgCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline MsgCmd& operator=(MsgCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MsgCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const MsgCmd* internal_default_instance() {
    return reinterpret_cast<const MsgCmd*>(
               &_MsgCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MsgCmd& a, MsgCmd& b) {
    a.Swap(&b);
  }
  inline void Swap(MsgCmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MsgCmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MsgCmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MsgCmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MsgCmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MsgCmd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgCmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.MsgCmd";
  }
  protected:
  explicit MsgCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // bytes Payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .message.CmdType Type = 1;
  void clear_type();
  ::message::CmdType type() const;
  void set_type(::message::CmdType value);
  private:
  ::message::CmdType _internal_type() const;
  void _internal_set_type(::message::CmdType value);
  public:

  // @@protoc_insertion_point(class_scope:message.MsgCmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class UPMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.UPMsg) */ {
 public:
  inline UPMsg() : UPMsg(nullptr) {}
  ~UPMsg() override;
  explicit constexpr UPMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UPMsg(const UPMsg& from);
  UPMsg(UPMsg&& from) noexcept
    : UPMsg() {
    *this = ::std::move(from);
  }

  inline UPMsg& operator=(const UPMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline UPMsg& operator=(UPMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UPMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const UPMsg* internal_default_instance() {
    return reinterpret_cast<const UPMsg*>(
               &_UPMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UPMsg& a, UPMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(UPMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UPMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UPMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UPMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UPMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UPMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UPMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.UPMsg";
  }
  protected:
  explicit UPMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUPMsgBodyFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // bytes UPMsgBody = 2;
  void clear_upmsgbody();
  const std::string& upmsgbody() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_upmsgbody(ArgT0&& arg0, ArgT... args);
  std::string* mutable_upmsgbody();
  PROTOBUF_NODISCARD std::string* release_upmsgbody();
  void set_allocated_upmsgbody(std::string* upmsgbody);
  private:
  const std::string& _internal_upmsgbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_upmsgbody(const std::string& value);
  std::string* _internal_mutable_upmsgbody();
  public:

  // .message.UPMsgHead Head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::message::UPMsgHead& head() const;
  PROTOBUF_NODISCARD ::message::UPMsgHead* release_head();
  ::message::UPMsgHead* mutable_head();
  void set_allocated_head(::message::UPMsgHead* head);
  private:
  const ::message::UPMsgHead& _internal_head() const;
  ::message::UPMsgHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::message::UPMsgHead* head);
  ::message::UPMsgHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:message.UPMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upmsgbody_;
  ::message::UPMsgHead* head_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class UPMsgHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.UPMsgHead) */ {
 public:
  inline UPMsgHead() : UPMsgHead(nullptr) {}
  ~UPMsgHead() override;
  explicit constexpr UPMsgHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UPMsgHead(const UPMsgHead& from);
  UPMsgHead(UPMsgHead&& from) noexcept
    : UPMsgHead() {
    *this = ::std::move(from);
  }

  inline UPMsgHead& operator=(const UPMsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline UPMsgHead& operator=(UPMsgHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UPMsgHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const UPMsgHead* internal_default_instance() {
    return reinterpret_cast<const UPMsgHead*>(
               &_UPMsgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UPMsgHead& a, UPMsgHead& b) {
    a.Swap(&b);
  }
  inline void Swap(UPMsgHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UPMsgHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UPMsgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UPMsgHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UPMsgHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UPMsgHead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UPMsgHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.UPMsgHead";
  }
  protected:
  explicit UPMsgHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 3,
    kClientIDFieldNumber = 1,
    kConnIDFieldNumber = 2,
  };
  // string SessionId = 3;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // uint64 ClientID = 1;
  void clear_clientid();
  uint64_t clientid() const;
  void set_clientid(uint64_t value);
  private:
  uint64_t _internal_clientid() const;
  void _internal_set_clientid(uint64_t value);
  public:

  // uint64 ConnID = 2;
  void clear_connid();
  uint64_t connid() const;
  void set_connid(uint64_t value);
  private:
  uint64_t _internal_connid() const;
  void _internal_set_connid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.UPMsgHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  uint64_t clientid_;
  uint64_t connid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class PushMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.PushMsg) */ {
 public:
  inline PushMsg() : PushMsg(nullptr) {}
  ~PushMsg() override;
  explicit constexpr PushMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushMsg(const PushMsg& from);
  PushMsg(PushMsg&& from) noexcept
    : PushMsg() {
    *this = ::std::move(from);
  }

  inline PushMsg& operator=(const PushMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushMsg& operator=(PushMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushMsg* internal_default_instance() {
    return reinterpret_cast<const PushMsg*>(
               &_PushMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PushMsg& a, PushMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(PushMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.PushMsg";
  }
  protected:
  explicit PushMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
    kMsgIDFieldNumber = 1,
    kSessionIDFieldNumber = 2,
  };
  // bytes Content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // uint64 MsgID = 1;
  void clear_msgid();
  uint64_t msgid() const;
  void set_msgid(uint64_t value);
  private:
  uint64_t _internal_msgid() const;
  void _internal_set_msgid(uint64_t value);
  public:

  // uint64 SessionID = 2;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.PushMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  uint64_t msgid_;
  uint64_t sessionid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ACKMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.ACKMsg) */ {
 public:
  inline ACKMsg() : ACKMsg(nullptr) {}
  ~ACKMsg() override;
  explicit constexpr ACKMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ACKMsg(const ACKMsg& from);
  ACKMsg(ACKMsg&& from) noexcept
    : ACKMsg() {
    *this = ::std::move(from);
  }

  inline ACKMsg& operator=(const ACKMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ACKMsg& operator=(ACKMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ACKMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ACKMsg* internal_default_instance() {
    return reinterpret_cast<const ACKMsg*>(
               &_ACKMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ACKMsg& a, ACKMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ACKMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ACKMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ACKMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ACKMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ACKMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ACKMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACKMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.ACKMsg";
  }
  protected:
  explicit ACKMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kCodeFieldNumber = 1,
    kTypeFieldNumber = 3,
    kConnIDFieldNumber = 4,
    kClientIDFieldNumber = 5,
    kSessionIDFieldNumber = 6,
    kMsgIDFieldNumber = 7,
  };
  // string Msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // uint32 Code = 1;
  void clear_code();
  uint32_t code() const;
  void set_code(uint32_t value);
  private:
  uint32_t _internal_code() const;
  void _internal_set_code(uint32_t value);
  public:

  // .message.CmdType Type = 3;
  void clear_type();
  ::message::CmdType type() const;
  void set_type(::message::CmdType value);
  private:
  ::message::CmdType _internal_type() const;
  void _internal_set_type(::message::CmdType value);
  public:

  // uint64 ConnID = 4;
  void clear_connid();
  uint64_t connid() const;
  void set_connid(uint64_t value);
  private:
  uint64_t _internal_connid() const;
  void _internal_set_connid(uint64_t value);
  public:

  // uint64 ClientID = 5;
  void clear_clientid();
  uint64_t clientid() const;
  void set_clientid(uint64_t value);
  private:
  uint64_t _internal_clientid() const;
  void _internal_set_clientid(uint64_t value);
  public:

  // uint64 SessionID = 6;
  void clear_sessionid();
  uint64_t sessionid() const;
  void set_sessionid(uint64_t value);
  private:
  uint64_t _internal_sessionid() const;
  void _internal_set_sessionid(uint64_t value);
  public:

  // uint64 MsgID = 7;
  void clear_msgid();
  uint64_t msgid() const;
  void set_msgid(uint64_t value);
  private:
  uint64_t _internal_msgid() const;
  void _internal_set_msgid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.ACKMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  uint32_t code_;
  int type_;
  uint64_t connid_;
  uint64_t clientid_;
  uint64_t sessionid_;
  uint64_t msgid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class LoginMsgHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.LoginMsgHead) */ {
 public:
  inline LoginMsgHead() : LoginMsgHead(nullptr) {}
  ~LoginMsgHead() override;
  explicit constexpr LoginMsgHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginMsgHead(const LoginMsgHead& from);
  LoginMsgHead(LoginMsgHead&& from) noexcept
    : LoginMsgHead() {
    *this = ::std::move(from);
  }

  inline LoginMsgHead& operator=(const LoginMsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginMsgHead& operator=(LoginMsgHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginMsgHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginMsgHead* internal_default_instance() {
    return reinterpret_cast<const LoginMsgHead*>(
               &_LoginMsgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LoginMsgHead& a, LoginMsgHead& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginMsgHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginMsgHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginMsgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginMsgHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginMsgHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginMsgHead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginMsgHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.LoginMsgHead";
  }
  protected:
  explicit LoginMsgHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIDFieldNumber = 1,
  };
  // uint64 DeviceID = 1;
  void clear_deviceid();
  uint64_t deviceid() const;
  void set_deviceid(uint64_t value);
  private:
  uint64_t _internal_deviceid() const;
  void _internal_set_deviceid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.LoginMsgHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t deviceid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class LoginMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.LoginMsg) */ {
 public:
  inline LoginMsg() : LoginMsg(nullptr) {}
  ~LoginMsg() override;
  explicit constexpr LoginMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginMsg(const LoginMsg& from);
  LoginMsg(LoginMsg&& from) noexcept
    : LoginMsg() {
    *this = ::std::move(from);
  }

  inline LoginMsg& operator=(const LoginMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginMsg& operator=(LoginMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginMsg* internal_default_instance() {
    return reinterpret_cast<const LoginMsg*>(
               &_LoginMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginMsg& a, LoginMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.LoginMsg";
  }
  protected:
  explicit LoginMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginMsgBodyFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // bytes LoginMsgBody = 2;
  void clear_loginmsgbody();
  const std::string& loginmsgbody() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loginmsgbody(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loginmsgbody();
  PROTOBUF_NODISCARD std::string* release_loginmsgbody();
  void set_allocated_loginmsgbody(std::string* loginmsgbody);
  private:
  const std::string& _internal_loginmsgbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loginmsgbody(const std::string& value);
  std::string* _internal_mutable_loginmsgbody();
  public:

  // .message.LoginMsgHead Head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::message::LoginMsgHead& head() const;
  PROTOBUF_NODISCARD ::message::LoginMsgHead* release_head();
  ::message::LoginMsgHead* mutable_head();
  void set_allocated_head(::message::LoginMsgHead* head);
  private:
  const ::message::LoginMsgHead& _internal_head() const;
  ::message::LoginMsgHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::message::LoginMsgHead* head);
  ::message::LoginMsgHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:message.LoginMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loginmsgbody_;
  ::message::LoginMsgHead* head_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatMsgHead final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:message.HeartbeatMsgHead) */ {
 public:
  inline HeartbeatMsgHead() : HeartbeatMsgHead(nullptr) {}
  explicit constexpr HeartbeatMsgHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatMsgHead(const HeartbeatMsgHead& from);
  HeartbeatMsgHead(HeartbeatMsgHead&& from) noexcept
    : HeartbeatMsgHead() {
    *this = ::std::move(from);
  }

  inline HeartbeatMsgHead& operator=(const HeartbeatMsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatMsgHead& operator=(HeartbeatMsgHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatMsgHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatMsgHead* internal_default_instance() {
    return reinterpret_cast<const HeartbeatMsgHead*>(
               &_HeartbeatMsgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HeartbeatMsgHead& a, HeartbeatMsgHead& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatMsgHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatMsgHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatMsgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatMsgHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeartbeatMsgHead& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeartbeatMsgHead& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.HeartbeatMsgHead";
  }
  protected:
  explicit HeartbeatMsgHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.HeartbeatMsgHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.HeartbeatMsg) */ {
 public:
  inline HeartbeatMsg() : HeartbeatMsg(nullptr) {}
  ~HeartbeatMsg() override;
  explicit constexpr HeartbeatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatMsg(const HeartbeatMsg& from);
  HeartbeatMsg(HeartbeatMsg&& from) noexcept
    : HeartbeatMsg() {
    *this = ::std::move(from);
  }

  inline HeartbeatMsg& operator=(const HeartbeatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatMsg& operator=(HeartbeatMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatMsg* internal_default_instance() {
    return reinterpret_cast<const HeartbeatMsg*>(
               &_HeartbeatMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HeartbeatMsg& a, HeartbeatMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartbeatMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.HeartbeatMsg";
  }
  protected:
  explicit HeartbeatMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartbeatMsgBodyFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // bytes HeartbeatMsgBody = 2;
  void clear_heartbeatmsgbody();
  const std::string& heartbeatmsgbody() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_heartbeatmsgbody(ArgT0&& arg0, ArgT... args);
  std::string* mutable_heartbeatmsgbody();
  PROTOBUF_NODISCARD std::string* release_heartbeatmsgbody();
  void set_allocated_heartbeatmsgbody(std::string* heartbeatmsgbody);
  private:
  const std::string& _internal_heartbeatmsgbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_heartbeatmsgbody(const std::string& value);
  std::string* _internal_mutable_heartbeatmsgbody();
  public:

  // .message.HeartbeatMsgHead Head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::message::HeartbeatMsgHead& head() const;
  PROTOBUF_NODISCARD ::message::HeartbeatMsgHead* release_head();
  ::message::HeartbeatMsgHead* mutable_head();
  void set_allocated_head(::message::HeartbeatMsgHead* head);
  private:
  const ::message::HeartbeatMsgHead& _internal_head() const;
  ::message::HeartbeatMsgHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::message::HeartbeatMsgHead* head);
  ::message::HeartbeatMsgHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:message.HeartbeatMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heartbeatmsgbody_;
  ::message::HeartbeatMsgHead* head_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ReConnMsgHead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.ReConnMsgHead) */ {
 public:
  inline ReConnMsgHead() : ReConnMsgHead(nullptr) {}
  ~ReConnMsgHead() override;
  explicit constexpr ReConnMsgHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReConnMsgHead(const ReConnMsgHead& from);
  ReConnMsgHead(ReConnMsgHead&& from) noexcept
    : ReConnMsgHead() {
    *this = ::std::move(from);
  }

  inline ReConnMsgHead& operator=(const ReConnMsgHead& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReConnMsgHead& operator=(ReConnMsgHead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReConnMsgHead& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReConnMsgHead* internal_default_instance() {
    return reinterpret_cast<const ReConnMsgHead*>(
               &_ReConnMsgHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReConnMsgHead& a, ReConnMsgHead& b) {
    a.Swap(&b);
  }
  inline void Swap(ReConnMsgHead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReConnMsgHead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReConnMsgHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReConnMsgHead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReConnMsgHead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReConnMsgHead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReConnMsgHead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.ReConnMsgHead";
  }
  protected:
  explicit ReConnMsgHead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnIDFieldNumber = 1,
  };
  // uint64 ConnID = 1;
  void clear_connid();
  uint64_t connid() const;
  void set_connid(uint64_t value);
  private:
  uint64_t _internal_connid() const;
  void _internal_set_connid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:message.ReConnMsgHead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t connid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ReConnMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message.ReConnMsg) */ {
 public:
  inline ReConnMsg() : ReConnMsg(nullptr) {}
  ~ReConnMsg() override;
  explicit constexpr ReConnMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReConnMsg(const ReConnMsg& from);
  ReConnMsg(ReConnMsg&& from) noexcept
    : ReConnMsg() {
    *this = ::std::move(from);
  }

  inline ReConnMsg& operator=(const ReConnMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReConnMsg& operator=(ReConnMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReConnMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReConnMsg* internal_default_instance() {
    return reinterpret_cast<const ReConnMsg*>(
               &_ReConnMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ReConnMsg& a, ReConnMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ReConnMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReConnMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReConnMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReConnMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReConnMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReConnMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReConnMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message.ReConnMsg";
  }
  protected:
  explicit ReConnMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReConnMsgBodyFieldNumber = 2,
    kHeadFieldNumber = 1,
  };
  // bytes ReConnMsgBody = 2;
  void clear_reconnmsgbody();
  const std::string& reconnmsgbody() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reconnmsgbody(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reconnmsgbody();
  PROTOBUF_NODISCARD std::string* release_reconnmsgbody();
  void set_allocated_reconnmsgbody(std::string* reconnmsgbody);
  private:
  const std::string& _internal_reconnmsgbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reconnmsgbody(const std::string& value);
  std::string* _internal_mutable_reconnmsgbody();
  public:

  // .message.ReConnMsgHead Head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::message::ReConnMsgHead& head() const;
  PROTOBUF_NODISCARD ::message::ReConnMsgHead* release_head();
  ::message::ReConnMsgHead* mutable_head();
  void set_allocated_head(::message::ReConnMsgHead* head);
  private:
  const ::message::ReConnMsgHead& _internal_head() const;
  ::message::ReConnMsgHead* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::message::ReConnMsgHead* head);
  ::message::ReConnMsgHead* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:message.ReConnMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reconnmsgbody_;
  ::message::ReConnMsgHead* head_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgCmd

// .message.CmdType Type = 1;
inline void MsgCmd::clear_type() {
  type_ = 0;
}
inline ::message::CmdType MsgCmd::_internal_type() const {
  return static_cast< ::message::CmdType >(type_);
}
inline ::message::CmdType MsgCmd::type() const {
  // @@protoc_insertion_point(field_get:message.MsgCmd.Type)
  return _internal_type();
}
inline void MsgCmd::_internal_set_type(::message::CmdType value) {
  
  type_ = value;
}
inline void MsgCmd::set_type(::message::CmdType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:message.MsgCmd.Type)
}

// bytes Payload = 2;
inline void MsgCmd::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& MsgCmd::payload() const {
  // @@protoc_insertion_point(field_get:message.MsgCmd.Payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MsgCmd::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.MsgCmd.Payload)
}
inline std::string* MsgCmd::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:message.MsgCmd.Payload)
  return _s;
}
inline const std::string& MsgCmd::_internal_payload() const {
  return payload_.Get();
}
inline void MsgCmd::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MsgCmd::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MsgCmd::release_payload() {
  // @@protoc_insertion_point(field_release:message.MsgCmd.Payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MsgCmd::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.MsgCmd.Payload)
}

// -------------------------------------------------------------------

// UPMsg

// .message.UPMsgHead Head = 1;
inline bool UPMsg::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool UPMsg::has_head() const {
  return _internal_has_head();
}
inline void UPMsg::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::message::UPMsgHead& UPMsg::_internal_head() const {
  const ::message::UPMsgHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::UPMsgHead&>(
      ::message::_UPMsgHead_default_instance_);
}
inline const ::message::UPMsgHead& UPMsg::head() const {
  // @@protoc_insertion_point(field_get:message.UPMsg.Head)
  return _internal_head();
}
inline void UPMsg::unsafe_arena_set_allocated_head(
    ::message::UPMsgHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.UPMsg.Head)
}
inline ::message::UPMsgHead* UPMsg::release_head() {
  
  ::message::UPMsgHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::UPMsgHead* UPMsg::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:message.UPMsg.Head)
  
  ::message::UPMsgHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::message::UPMsgHead* UPMsg::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::UPMsgHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::message::UPMsgHead* UPMsg::mutable_head() {
  ::message::UPMsgHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:message.UPMsg.Head)
  return _msg;
}
inline void UPMsg::set_allocated_head(::message::UPMsgHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::message::UPMsgHead>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:message.UPMsg.Head)
}

// bytes UPMsgBody = 2;
inline void UPMsg::clear_upmsgbody() {
  upmsgbody_.ClearToEmpty();
}
inline const std::string& UPMsg::upmsgbody() const {
  // @@protoc_insertion_point(field_get:message.UPMsg.UPMsgBody)
  return _internal_upmsgbody();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UPMsg::set_upmsgbody(ArgT0&& arg0, ArgT... args) {
 
 upmsgbody_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.UPMsg.UPMsgBody)
}
inline std::string* UPMsg::mutable_upmsgbody() {
  std::string* _s = _internal_mutable_upmsgbody();
  // @@protoc_insertion_point(field_mutable:message.UPMsg.UPMsgBody)
  return _s;
}
inline const std::string& UPMsg::_internal_upmsgbody() const {
  return upmsgbody_.Get();
}
inline void UPMsg::_internal_set_upmsgbody(const std::string& value) {
  
  upmsgbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UPMsg::_internal_mutable_upmsgbody() {
  
  return upmsgbody_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UPMsg::release_upmsgbody() {
  // @@protoc_insertion_point(field_release:message.UPMsg.UPMsgBody)
  return upmsgbody_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UPMsg::set_allocated_upmsgbody(std::string* upmsgbody) {
  if (upmsgbody != nullptr) {
    
  } else {
    
  }
  upmsgbody_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), upmsgbody,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (upmsgbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    upmsgbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.UPMsg.UPMsgBody)
}

// -------------------------------------------------------------------

// UPMsgHead

// uint64 ClientID = 1;
inline void UPMsgHead::clear_clientid() {
  clientid_ = uint64_t{0u};
}
inline uint64_t UPMsgHead::_internal_clientid() const {
  return clientid_;
}
inline uint64_t UPMsgHead::clientid() const {
  // @@protoc_insertion_point(field_get:message.UPMsgHead.ClientID)
  return _internal_clientid();
}
inline void UPMsgHead::_internal_set_clientid(uint64_t value) {
  
  clientid_ = value;
}
inline void UPMsgHead::set_clientid(uint64_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:message.UPMsgHead.ClientID)
}

// uint64 ConnID = 2;
inline void UPMsgHead::clear_connid() {
  connid_ = uint64_t{0u};
}
inline uint64_t UPMsgHead::_internal_connid() const {
  return connid_;
}
inline uint64_t UPMsgHead::connid() const {
  // @@protoc_insertion_point(field_get:message.UPMsgHead.ConnID)
  return _internal_connid();
}
inline void UPMsgHead::_internal_set_connid(uint64_t value) {
  
  connid_ = value;
}
inline void UPMsgHead::set_connid(uint64_t value) {
  _internal_set_connid(value);
  // @@protoc_insertion_point(field_set:message.UPMsgHead.ConnID)
}

// string SessionId = 3;
inline void UPMsgHead::clear_sessionid() {
  sessionid_.ClearToEmpty();
}
inline const std::string& UPMsgHead::sessionid() const {
  // @@protoc_insertion_point(field_get:message.UPMsgHead.SessionId)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UPMsgHead::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.UPMsgHead.SessionId)
}
inline std::string* UPMsgHead::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:message.UPMsgHead.SessionId)
  return _s;
}
inline const std::string& UPMsgHead::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void UPMsgHead::_internal_set_sessionid(const std::string& value) {
  
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UPMsgHead::_internal_mutable_sessionid() {
  
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UPMsgHead::release_sessionid() {
  // @@protoc_insertion_point(field_release:message.UPMsgHead.SessionId)
  return sessionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UPMsgHead::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.UPMsgHead.SessionId)
}

// -------------------------------------------------------------------

// PushMsg

// uint64 MsgID = 1;
inline void PushMsg::clear_msgid() {
  msgid_ = uint64_t{0u};
}
inline uint64_t PushMsg::_internal_msgid() const {
  return msgid_;
}
inline uint64_t PushMsg::msgid() const {
  // @@protoc_insertion_point(field_get:message.PushMsg.MsgID)
  return _internal_msgid();
}
inline void PushMsg::_internal_set_msgid(uint64_t value) {
  
  msgid_ = value;
}
inline void PushMsg::set_msgid(uint64_t value) {
  _internal_set_msgid(value);
  // @@protoc_insertion_point(field_set:message.PushMsg.MsgID)
}

// uint64 SessionID = 2;
inline void PushMsg::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t PushMsg::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t PushMsg::sessionid() const {
  // @@protoc_insertion_point(field_get:message.PushMsg.SessionID)
  return _internal_sessionid();
}
inline void PushMsg::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void PushMsg::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:message.PushMsg.SessionID)
}

// bytes Content = 3;
inline void PushMsg::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& PushMsg::content() const {
  // @@protoc_insertion_point(field_get:message.PushMsg.Content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushMsg::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.PushMsg.Content)
}
inline std::string* PushMsg::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:message.PushMsg.Content)
  return _s;
}
inline const std::string& PushMsg::_internal_content() const {
  return content_.Get();
}
inline void PushMsg::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PushMsg::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PushMsg::release_content() {
  // @@protoc_insertion_point(field_release:message.PushMsg.Content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PushMsg::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (content_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    content_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.PushMsg.Content)
}

// -------------------------------------------------------------------

// ACKMsg

// uint32 Code = 1;
inline void ACKMsg::clear_code() {
  code_ = 0u;
}
inline uint32_t ACKMsg::_internal_code() const {
  return code_;
}
inline uint32_t ACKMsg::code() const {
  // @@protoc_insertion_point(field_get:message.ACKMsg.Code)
  return _internal_code();
}
inline void ACKMsg::_internal_set_code(uint32_t value) {
  
  code_ = value;
}
inline void ACKMsg::set_code(uint32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:message.ACKMsg.Code)
}

// string Msg = 2;
inline void ACKMsg::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& ACKMsg::msg() const {
  // @@protoc_insertion_point(field_get:message.ACKMsg.Msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ACKMsg::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.ACKMsg.Msg)
}
inline std::string* ACKMsg::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:message.ACKMsg.Msg)
  return _s;
}
inline const std::string& ACKMsg::_internal_msg() const {
  return msg_.Get();
}
inline void ACKMsg::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ACKMsg::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ACKMsg::release_msg() {
  // @@protoc_insertion_point(field_release:message.ACKMsg.Msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ACKMsg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ACKMsg.Msg)
}

// .message.CmdType Type = 3;
inline void ACKMsg::clear_type() {
  type_ = 0;
}
inline ::message::CmdType ACKMsg::_internal_type() const {
  return static_cast< ::message::CmdType >(type_);
}
inline ::message::CmdType ACKMsg::type() const {
  // @@protoc_insertion_point(field_get:message.ACKMsg.Type)
  return _internal_type();
}
inline void ACKMsg::_internal_set_type(::message::CmdType value) {
  
  type_ = value;
}
inline void ACKMsg::set_type(::message::CmdType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:message.ACKMsg.Type)
}

// uint64 ConnID = 4;
inline void ACKMsg::clear_connid() {
  connid_ = uint64_t{0u};
}
inline uint64_t ACKMsg::_internal_connid() const {
  return connid_;
}
inline uint64_t ACKMsg::connid() const {
  // @@protoc_insertion_point(field_get:message.ACKMsg.ConnID)
  return _internal_connid();
}
inline void ACKMsg::_internal_set_connid(uint64_t value) {
  
  connid_ = value;
}
inline void ACKMsg::set_connid(uint64_t value) {
  _internal_set_connid(value);
  // @@protoc_insertion_point(field_set:message.ACKMsg.ConnID)
}

// uint64 ClientID = 5;
inline void ACKMsg::clear_clientid() {
  clientid_ = uint64_t{0u};
}
inline uint64_t ACKMsg::_internal_clientid() const {
  return clientid_;
}
inline uint64_t ACKMsg::clientid() const {
  // @@protoc_insertion_point(field_get:message.ACKMsg.ClientID)
  return _internal_clientid();
}
inline void ACKMsg::_internal_set_clientid(uint64_t value) {
  
  clientid_ = value;
}
inline void ACKMsg::set_clientid(uint64_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:message.ACKMsg.ClientID)
}

// uint64 SessionID = 6;
inline void ACKMsg::clear_sessionid() {
  sessionid_ = uint64_t{0u};
}
inline uint64_t ACKMsg::_internal_sessionid() const {
  return sessionid_;
}
inline uint64_t ACKMsg::sessionid() const {
  // @@protoc_insertion_point(field_get:message.ACKMsg.SessionID)
  return _internal_sessionid();
}
inline void ACKMsg::_internal_set_sessionid(uint64_t value) {
  
  sessionid_ = value;
}
inline void ACKMsg::set_sessionid(uint64_t value) {
  _internal_set_sessionid(value);
  // @@protoc_insertion_point(field_set:message.ACKMsg.SessionID)
}

// uint64 MsgID = 7;
inline void ACKMsg::clear_msgid() {
  msgid_ = uint64_t{0u};
}
inline uint64_t ACKMsg::_internal_msgid() const {
  return msgid_;
}
inline uint64_t ACKMsg::msgid() const {
  // @@protoc_insertion_point(field_get:message.ACKMsg.MsgID)
  return _internal_msgid();
}
inline void ACKMsg::_internal_set_msgid(uint64_t value) {
  
  msgid_ = value;
}
inline void ACKMsg::set_msgid(uint64_t value) {
  _internal_set_msgid(value);
  // @@protoc_insertion_point(field_set:message.ACKMsg.MsgID)
}

// -------------------------------------------------------------------

// LoginMsgHead

// uint64 DeviceID = 1;
inline void LoginMsgHead::clear_deviceid() {
  deviceid_ = uint64_t{0u};
}
inline uint64_t LoginMsgHead::_internal_deviceid() const {
  return deviceid_;
}
inline uint64_t LoginMsgHead::deviceid() const {
  // @@protoc_insertion_point(field_get:message.LoginMsgHead.DeviceID)
  return _internal_deviceid();
}
inline void LoginMsgHead::_internal_set_deviceid(uint64_t value) {
  
  deviceid_ = value;
}
inline void LoginMsgHead::set_deviceid(uint64_t value) {
  _internal_set_deviceid(value);
  // @@protoc_insertion_point(field_set:message.LoginMsgHead.DeviceID)
}

// -------------------------------------------------------------------

// LoginMsg

// .message.LoginMsgHead Head = 1;
inline bool LoginMsg::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool LoginMsg::has_head() const {
  return _internal_has_head();
}
inline void LoginMsg::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::message::LoginMsgHead& LoginMsg::_internal_head() const {
  const ::message::LoginMsgHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::LoginMsgHead&>(
      ::message::_LoginMsgHead_default_instance_);
}
inline const ::message::LoginMsgHead& LoginMsg::head() const {
  // @@protoc_insertion_point(field_get:message.LoginMsg.Head)
  return _internal_head();
}
inline void LoginMsg::unsafe_arena_set_allocated_head(
    ::message::LoginMsgHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.LoginMsg.Head)
}
inline ::message::LoginMsgHead* LoginMsg::release_head() {
  
  ::message::LoginMsgHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::LoginMsgHead* LoginMsg::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:message.LoginMsg.Head)
  
  ::message::LoginMsgHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::message::LoginMsgHead* LoginMsg::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::LoginMsgHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::message::LoginMsgHead* LoginMsg::mutable_head() {
  ::message::LoginMsgHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:message.LoginMsg.Head)
  return _msg;
}
inline void LoginMsg::set_allocated_head(::message::LoginMsgHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::message::LoginMsgHead>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:message.LoginMsg.Head)
}

// bytes LoginMsgBody = 2;
inline void LoginMsg::clear_loginmsgbody() {
  loginmsgbody_.ClearToEmpty();
}
inline const std::string& LoginMsg::loginmsgbody() const {
  // @@protoc_insertion_point(field_get:message.LoginMsg.LoginMsgBody)
  return _internal_loginmsgbody();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginMsg::set_loginmsgbody(ArgT0&& arg0, ArgT... args) {
 
 loginmsgbody_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.LoginMsg.LoginMsgBody)
}
inline std::string* LoginMsg::mutable_loginmsgbody() {
  std::string* _s = _internal_mutable_loginmsgbody();
  // @@protoc_insertion_point(field_mutable:message.LoginMsg.LoginMsgBody)
  return _s;
}
inline const std::string& LoginMsg::_internal_loginmsgbody() const {
  return loginmsgbody_.Get();
}
inline void LoginMsg::_internal_set_loginmsgbody(const std::string& value) {
  
  loginmsgbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginMsg::_internal_mutable_loginmsgbody() {
  
  return loginmsgbody_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginMsg::release_loginmsgbody() {
  // @@protoc_insertion_point(field_release:message.LoginMsg.LoginMsgBody)
  return loginmsgbody_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginMsg::set_allocated_loginmsgbody(std::string* loginmsgbody) {
  if (loginmsgbody != nullptr) {
    
  } else {
    
  }
  loginmsgbody_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), loginmsgbody,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (loginmsgbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    loginmsgbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.LoginMsg.LoginMsgBody)
}

// -------------------------------------------------------------------

// HeartbeatMsgHead

// -------------------------------------------------------------------

// HeartbeatMsg

// .message.HeartbeatMsgHead Head = 1;
inline bool HeartbeatMsg::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool HeartbeatMsg::has_head() const {
  return _internal_has_head();
}
inline void HeartbeatMsg::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::message::HeartbeatMsgHead& HeartbeatMsg::_internal_head() const {
  const ::message::HeartbeatMsgHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::HeartbeatMsgHead&>(
      ::message::_HeartbeatMsgHead_default_instance_);
}
inline const ::message::HeartbeatMsgHead& HeartbeatMsg::head() const {
  // @@protoc_insertion_point(field_get:message.HeartbeatMsg.Head)
  return _internal_head();
}
inline void HeartbeatMsg::unsafe_arena_set_allocated_head(
    ::message::HeartbeatMsgHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.HeartbeatMsg.Head)
}
inline ::message::HeartbeatMsgHead* HeartbeatMsg::release_head() {
  
  ::message::HeartbeatMsgHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::HeartbeatMsgHead* HeartbeatMsg::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:message.HeartbeatMsg.Head)
  
  ::message::HeartbeatMsgHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::message::HeartbeatMsgHead* HeartbeatMsg::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::HeartbeatMsgHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::message::HeartbeatMsgHead* HeartbeatMsg::mutable_head() {
  ::message::HeartbeatMsgHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:message.HeartbeatMsg.Head)
  return _msg;
}
inline void HeartbeatMsg::set_allocated_head(::message::HeartbeatMsgHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::message::HeartbeatMsgHead>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:message.HeartbeatMsg.Head)
}

// bytes HeartbeatMsgBody = 2;
inline void HeartbeatMsg::clear_heartbeatmsgbody() {
  heartbeatmsgbody_.ClearToEmpty();
}
inline const std::string& HeartbeatMsg::heartbeatmsgbody() const {
  // @@protoc_insertion_point(field_get:message.HeartbeatMsg.HeartbeatMsgBody)
  return _internal_heartbeatmsgbody();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatMsg::set_heartbeatmsgbody(ArgT0&& arg0, ArgT... args) {
 
 heartbeatmsgbody_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.HeartbeatMsg.HeartbeatMsgBody)
}
inline std::string* HeartbeatMsg::mutable_heartbeatmsgbody() {
  std::string* _s = _internal_mutable_heartbeatmsgbody();
  // @@protoc_insertion_point(field_mutable:message.HeartbeatMsg.HeartbeatMsgBody)
  return _s;
}
inline const std::string& HeartbeatMsg::_internal_heartbeatmsgbody() const {
  return heartbeatmsgbody_.Get();
}
inline void HeartbeatMsg::_internal_set_heartbeatmsgbody(const std::string& value) {
  
  heartbeatmsgbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HeartbeatMsg::_internal_mutable_heartbeatmsgbody() {
  
  return heartbeatmsgbody_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HeartbeatMsg::release_heartbeatmsgbody() {
  // @@protoc_insertion_point(field_release:message.HeartbeatMsg.HeartbeatMsgBody)
  return heartbeatmsgbody_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HeartbeatMsg::set_allocated_heartbeatmsgbody(std::string* heartbeatmsgbody) {
  if (heartbeatmsgbody != nullptr) {
    
  } else {
    
  }
  heartbeatmsgbody_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), heartbeatmsgbody,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (heartbeatmsgbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    heartbeatmsgbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.HeartbeatMsg.HeartbeatMsgBody)
}

// -------------------------------------------------------------------

// ReConnMsgHead

// uint64 ConnID = 1;
inline void ReConnMsgHead::clear_connid() {
  connid_ = uint64_t{0u};
}
inline uint64_t ReConnMsgHead::_internal_connid() const {
  return connid_;
}
inline uint64_t ReConnMsgHead::connid() const {
  // @@protoc_insertion_point(field_get:message.ReConnMsgHead.ConnID)
  return _internal_connid();
}
inline void ReConnMsgHead::_internal_set_connid(uint64_t value) {
  
  connid_ = value;
}
inline void ReConnMsgHead::set_connid(uint64_t value) {
  _internal_set_connid(value);
  // @@protoc_insertion_point(field_set:message.ReConnMsgHead.ConnID)
}

// -------------------------------------------------------------------

// ReConnMsg

// .message.ReConnMsgHead Head = 1;
inline bool ReConnMsg::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool ReConnMsg::has_head() const {
  return _internal_has_head();
}
inline void ReConnMsg::clear_head() {
  if (GetArenaForAllocation() == nullptr && head_ != nullptr) {
    delete head_;
  }
  head_ = nullptr;
}
inline const ::message::ReConnMsgHead& ReConnMsg::_internal_head() const {
  const ::message::ReConnMsgHead* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::message::ReConnMsgHead&>(
      ::message::_ReConnMsgHead_default_instance_);
}
inline const ::message::ReConnMsgHead& ReConnMsg::head() const {
  // @@protoc_insertion_point(field_get:message.ReConnMsg.Head)
  return _internal_head();
}
inline void ReConnMsg::unsafe_arena_set_allocated_head(
    ::message::ReConnMsgHead* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.ReConnMsg.Head)
}
inline ::message::ReConnMsgHead* ReConnMsg::release_head() {
  
  ::message::ReConnMsgHead* temp = head_;
  head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::message::ReConnMsgHead* ReConnMsg::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:message.ReConnMsg.Head)
  
  ::message::ReConnMsgHead* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::message::ReConnMsgHead* ReConnMsg::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::message::ReConnMsgHead>(GetArenaForAllocation());
    head_ = p;
  }
  return head_;
}
inline ::message::ReConnMsgHead* ReConnMsg::mutable_head() {
  ::message::ReConnMsgHead* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:message.ReConnMsg.Head)
  return _msg;
}
inline void ReConnMsg::set_allocated_head(::message::ReConnMsgHead* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::message::ReConnMsgHead>::GetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:message.ReConnMsg.Head)
}

// bytes ReConnMsgBody = 2;
inline void ReConnMsg::clear_reconnmsgbody() {
  reconnmsgbody_.ClearToEmpty();
}
inline const std::string& ReConnMsg::reconnmsgbody() const {
  // @@protoc_insertion_point(field_get:message.ReConnMsg.ReConnMsgBody)
  return _internal_reconnmsgbody();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReConnMsg::set_reconnmsgbody(ArgT0&& arg0, ArgT... args) {
 
 reconnmsgbody_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:message.ReConnMsg.ReConnMsgBody)
}
inline std::string* ReConnMsg::mutable_reconnmsgbody() {
  std::string* _s = _internal_mutable_reconnmsgbody();
  // @@protoc_insertion_point(field_mutable:message.ReConnMsg.ReConnMsgBody)
  return _s;
}
inline const std::string& ReConnMsg::_internal_reconnmsgbody() const {
  return reconnmsgbody_.Get();
}
inline void ReConnMsg::_internal_set_reconnmsgbody(const std::string& value) {
  
  reconnmsgbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReConnMsg::_internal_mutable_reconnmsgbody() {
  
  return reconnmsgbody_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReConnMsg::release_reconnmsgbody() {
  // @@protoc_insertion_point(field_release:message.ReConnMsg.ReConnMsgBody)
  return reconnmsgbody_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReConnMsg::set_allocated_reconnmsgbody(std::string* reconnmsgbody) {
  if (reconnmsgbody != nullptr) {
    
  } else {
    
  }
  reconnmsgbody_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reconnmsgbody,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reconnmsgbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reconnmsgbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.ReConnMsg.ReConnMsgBody)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::message::CmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message::CmdType>() {
  return ::message::CmdType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
